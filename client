#!/usr/bin/env python3
import socket, ssl, json, certifi, argparse, sys

# Helper to send to server
def send_json_line(sock, obj):
    json_string = json.dumps(obj, separators=(",", ":"))
    byte_data = json_string.encode("ascii")
    byte_data += b"\n"
    sock.sendall(byte_data)

# Helper to load chunks seperate messages with buffer for \n
def recv_line(sock, buf):
    while True:
        new_line_index = buf.find(b"\n")
        if new_line_index != -1: # we hit a \n
            line = bytes(buf[:new_line_index]) # capture the full line
            del buf[:new_line_index + 1] # remove line and new line
            return line
        chunk = sock.recv(4096) # load next chunk
        if chunk == b"":
            raise ConnectionError("server closed connection")
        buf.extend(chunk) # add chunk to buffer


# Helper to recieve and turn bytes to proper json messages
def recv_json(sock, buf): 
    byte_line = recv_line(sock, buf)
    str_line = byte_line.decode("ascii")
    return json.loads(str_line)

# Helper for backend logic guessing wordle simulating the marks
def simulate(secret, guess):
    marks = [0] * 5
    secret_left = list(secret)  # letters we can still match for "1"s
    # exact matches
    for i in range(5):
        if guess[i] == secret[i]:
            marks[i] = 2
            secret_left[i] = None # consume
    # wrong-position matches, second pass
    for i in range(5):
        if marks[i] != 0:
            continue
        ch = guess[i]
        if ch in secret_left:
            marks[i] = 1
            secret_left[secret_left.index(ch)] = None
    return marks


def main():
    # deal with flags and set up
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", dest="port", type=int)
    parser.add_argument("-s", dest="tls", action="store_true")
    parser.add_argument("hostname")
    parser.add_argument("username")
    args = parser.parse_args()

    # variables
    max_guesses = 500 # as outlined in project description
    use_tls = args.tls
    username = args.username
    hostname = args.hostname
    hello = {
        "type": "hello",
        "northeastern_username" : username
    }

    # conditional tag logic for TCP 27993 vs TLS 27994
    if args.port is None:
        if use_tls: port = 27994
        else: port = 27993
    else:
        port = args.port

    buf = bytearray() # buffer for loading/saving chunks
    sock = socket.create_connection((hostname, port), None)
    try:
        # wrap socket for cryptographic layer for TLS, SSL runs over TCP connection
        if use_tls:
            context = ssl.create_default_context(cafile=certifi.where())
            sock = context.wrap_socket(sock, server_hostname = hostname)

        # send hello and extract game id
        send_json_line(sock, hello)
        hello_msg = recv_json(sock, buf)
        # error handling
        if hello_msg.get("type") == "error":
            print(hello_msg.get("message", "unknown error"), file=sys.stderr)
            return
        if hello_msg.get("type") != "start" or "id" not in hello_msg:
            print(f"protocol error: {hello_msg}", file=sys.stderr)
            return

        game_id = hello_msg["id"]

        # load words
        with open("project1-words.txt", "r", encoding="ascii") as f:
            words = [line.strip() for line in f if line.strip()]
        candidates = words[:]

        # guessing loop for wordle
        for _ in range(max_guesses):
            if not candidates:
                print("no candidates left", file=sys.stderr)
                return
            # guess word
            word_guess = candidates[0]
            guess = {"type":"guess","id": game_id, "word": word_guess}
            send_json_line(sock, guess)
            reply_msg = recv_json(sock, buf)
            reply_type = reply_msg.get("type")

            # handle reply and eror handling
            if reply_type == "bye":
                flag = reply_msg.get("flag")
                if not flag:
                    print(f"protocol error: missing flag", file=sys.stderr)
                    return
                print(flag)
                return
            if reply_type == "error":
                print(reply_msg.get("message", "unknown error"), file=sys.stderr)
                return
            if reply_type != "retry":
                print(f"protocol error: {reply_type}", file=sys.stderr)
                return
            
            last_entry = reply_msg["guesses"][-1]
            last_guess = last_entry["word"]
            marks = last_entry["marks"]
            
            # filter and simulate marks
            new_candidates = []
            for word in candidates:
                candidate_marks = simulate(word, last_guess)
                if candidate_marks == marks:
                    new_candidates.append(word)
            candidates = new_candidates
    finally:
        # close socket
        sock.close()

if __name__ == "__main__":
    main()